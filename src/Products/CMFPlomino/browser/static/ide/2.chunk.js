webpackJsonp([2],{

/***/ 1381:
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * A Base pattern for creating scoped patterns. It's similar to Backbone's\n * Model class. The advantage of this approach is that each instance of a\n * pattern has its own local scope (closure).\n *\n * A new instance is created for each DOM element on which a pattern applies.\n *\n * You can assign values, such as $el, to `this` for an instance and they\n * will remain unique to that instance.\n *\n * Older Patternslib patterns on the other hand have a single global scope for\n * all DOM elements.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n  __webpack_require__(550),\n  __webpack_require__(1292),\n  __webpack_require__(1382),\n  __webpack_require__(1293)\n], __WEBPACK_AMD_DEFINE_RESULT__ = function($, Registry, mockupParser, logger) {\n    \"use strict\";\n    var log = logger.getLogger(\"Patternslib Base\");\n\n    var initBasePattern = function initBasePattern($el, options, trigger) {\n        var name = this.prototype.name;\n        var log = logger.getLogger(\"pat.\" + name);\n        var pattern = $el.data(\"pattern-\" + name);\n        if (pattern === undefined && Registry.patterns[name]) {\n            try {\n                options = this.prototype.parser  === \"mockup\" ? mockupParser.getOptions($el, name, options) : options;\n                pattern = new Registry.patterns[name]($el, options, trigger);\n            } catch (e) {\n                log.error(\"Failed while initializing '\" + name + \"' pattern.\", e);\n            }\n            $el.data(\"pattern-\" + name, pattern);\n        }\n        return pattern;\n    };\n\n    var Base = function($el, options, trigger) {\n        this.$el = $el;\n        this.options = $.extend(true, {}, this.defaults || {}, options || {});\n        this.init($el, options, trigger);\n        this.emit(\"init\");\n    };\n\n    Base.prototype = {\n        constructor: Base,\n        on: function(eventName, eventCallback) {\n            this.$el.on(eventName + \".\" + this.name + \".patterns\", eventCallback);\n        },\n        emit: function(eventName, args) {\n            // args should be a list\n            if (args === undefined) {\n                args = [];\n            }\n            this.$el.trigger(eventName + \".\" + this.name + \".patterns\", args);\n        }\n    };\n\n    Base.extend = function(patternProps) {\n        /* Helper function to correctly set up the prototype chain for new patterns.\n        */\n        var parent = this;\n        var child;\n\n        // Check that the required configuration properties are given.\n        if (!patternProps) {\n            throw new Error(\"Pattern configuration properties required when calling Base.extend\");\n        }\n\n        // The constructor function for the new subclass is either defined by you\n        // (the \"constructor\" property in your `extend` definition), or defaulted\n        // by us to simply call the parent's constructor.\n        if (patternProps.hasOwnProperty(\"constructor\")) {\n            child = patternProps.constructor;\n        } else {\n            child = function() { parent.apply(this, arguments); };\n        }\n\n        // Allow patterns to be extended indefinitely\n        child.extend = Base.extend;\n\n        // Static properties required by the Patternslib registry \n        child.init = initBasePattern;\n        child.jquery_plugin = true;\n        child.trigger = patternProps.trigger;\n\n        // Set the prototype chain to inherit from `parent`, without calling\n        // `parent`'s constructor function.\n        var Surrogate = function() { this.constructor = child; };\n        Surrogate.prototype = parent.prototype;\n        child.prototype = new Surrogate();\n\n        // Add pattern's configuration properties (instance properties) to the subclass,\n        $.extend(true, child.prototype, patternProps);\n\n        // Set a convenience property in case the parent's prototype is needed\n        // later.\n        child.__super__ = parent.prototype;\n\n        // Register the pattern in the Patternslib registry.\n        if (!patternProps.name) {\n            log.warn(\"This pattern without a name attribute will not be registered!\");\n        } else if (!patternProps.trigger) {\n            log.warn(\"The pattern '\"+patternProps.name+\"' does not \" +\n                     \"have a trigger attribute, it will not be registered.\");\n        } else {\n            Registry.register(child, patternProps.name);\n        }\n        return child;\n    };\n    return Base;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/patternslib/src/core/base.js\n// module id = 1381\n// module chunks = 1 2\n//# sourceURL=webpack:///./~/patternslib/src/core/base.js?");

/***/ }),

/***/ 1382:
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n    __webpack_require__(550)\n], __WEBPACK_AMD_DEFINE_RESULT__ = function($) {\n    'use strict';\n\n    var parser = {\n        getOptions: function getOptions($el, patternName, options) {\n            /* This is the Mockup parser. An alternative parser for Patternslib\n             * patterns.\n             *\n             * NOTE: Use of the Mockup parser is discouraged and is added here for\n             * legacy support for the Plone Mockup project.\n             *\n             * It parses a DOM element for pattern configuration options.\n             */\n            options = options || {};\n            // get options from parent element first, stop if element tag name is 'body'\n            if ($el.length !== 0 && !$.nodeName($el[0], 'body')) {\n                options = getOptions($el.parent(), patternName, options);\n            }\n            // collect all options from element\n            var elOptions = {};\n            if ($el.length !== 0) {\n                elOptions = $el.data('pat-' + patternName);\n                if (elOptions) {\n                    // parse options if string\n                    if (typeof(elOptions) === 'string') {\n                        var tmpOptions = {};\n                        $.each(elOptions.split(';'),\n                            function(i, item) {\n                                item = item.split(':');\n                                item.reverse();\n                                var key = item.pop();\n                                key = key.replace(/^\\s+|\\s+$/g, '');    // trim\n                                item.reverse();\n                                var value = item.join(':');\n                                value = value.replace(/^\\s+|\\s+$/g, '');    // trim\n                                tmpOptions[key] = value;\n                            }\n                        );\n                        elOptions = tmpOptions;\n                    }\n                }\n            }\n            return $.extend(true, {}, options, elOptions);\n        }\n    };\n    return parser;\n}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/patternslib/src/core/mockup-parser.js\n// module id = 1382\n// module chunks = 1 2\n//# sourceURL=webpack:///./~/patternslib/src/core/mockup-parser.js?");

/***/ })

});